# Занятие 1. Знакомство с языком

## Особенности Python (типизация, парадигма)

Python - язык программирования с динамической строгой типизацией. Реализует объектно-ориентированную парадигму, причем,
каждое значение в языке является обьектом.

## Типы данных и операции с ними

### Типы данных

В питоне есть несколько стандартных типов данных.

|       Название       | Тип     | Описание                                                                     | Изменяемое |
|:--------------------:|---------|:-----------------------------------------------------------------------------|------------|
|     Целые числа      | int     | 1, 2, 3                                                                      | Нет        |
| Числа с плав. точкой | float   | 1.1, 12.04, 4.0                                                              | Нет        |
|        Строки        | str     | Последовательность символов:<br /> "Hello, World", 'Hello', """BIG STRING""" | Нет        |
|        Списки        | list    | Последовательность объектов: [1, 2.9, 'Hi']                                  | Да         |
|       Словари        | dict    | Список пар ключ-значение:<br />{'key1': 'value1', 'key2': 2}                 | Да         |
|       Кортежи        | tuple   | Последовательность неизменяемых объектов: ()                                 | Нет        |
|      Множества       | set     | Неупорядоченный набор уникальных объектов: {'a', 'b', 'c'}                   | Да         |
|   Булевы значения    | bool    | True, False                                                                  | Нет        |
|  Комплексные числа   | complex | -5i, 3+2i                                                                    | Нет        |

Также в языке существует особое значение `None`, которое является аналогом `null` в дргих ЯП и обозначает НИ-ЧЕ-ГО, т.е.
полное отсутствие значения.

Язык является динамически типизированным, т.е. типы указывать не обязательно, но начиная с версии 3.5 появилась
возможность аннотировать типы, делать это или нет осатется на усмотрение разработчика, но это считается правилом
хорошего тона. И помогает лучше читать код. Не все бибилиотеки и фреймворки на данный момент типизированы, но постепенно
их процент снижается.

Пример:

```python
name: str = 'Hello, World!'


def print_age(age: int) -> str:
    return 'Your age is ' + str(age)
```

Из-за строгой типизации, при приведении одного типа к другому эти действия надо выполнять в явном виде.

Пример:

```python
some_num: int = 1231
some_str: str = str(some_num)
```

Типы бывают изменяемыми и неизменяемыми, различие в том, что при передаче их в функцию изменяемые передаются по ссылке,
а неизменяемые по значению, также при присвоении переменных этот принцип сохраняется.

### Операции с типами

Числа поддерживают стандартные арифметические операции:

| **Приоритет** | **Оператор Python** | **Операция**                                        | **Пример** | **Результат** |
|---------------|---------------------|-----------------------------------------------------|------------|---------------|
| 1             | **                  | Возведение в степень                                | 5 ** 5     | 3125          |
| 2             | **%**               | Деление по модулю (получение остатка)               | 16 % 7     | 2             |
| 3             | **//**              | Целочисленное деление (дробная часть отбрасывается) | 13 // 3    | 4             |
| 4             | **/**               | Деление                                             | 39 / 2     | 19.5          |
| 5             | *                   | Умножение                                           | 123 * 321  | 39483         |
| 6             | **-**               | Вычитание                                           | 999 – 135  | 864           |
| 7             | **+**               | Сложение                                            | 478 + 32   | 510           |

Также существует конкатенация строк:

```python
'Hello' + ' ' + 'World' == 'Hello World'
```

Операторы сравнения:

| Оператор | Описание                                                                                                            | Примеры                                                                                                                  |
|----------|---------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| **==**   | Проверяет равны ли оба операнда. Если да, то условие становится истинным.                                           | 5 == 5 в результате будет True<br/>True == False в результате будет False<br/>"hello" == "hello" в результате будет True |
| **!=**   | Проверяет равны ли оба операнда. Если нет, то условие становится истинным.                                          | 12 != 5 в результате будет True<br/>False != False в результате будет False<br/>"hi" != "Hi" в результате будет True     |
| **<>**   | Проверяет равны ли оба операнда. Если нет, то условие становится истинным.                                          | 12 <> 5 в результате будет True. Похоже на оператор !=                                                                   |
| **>**    | Проверяет больше ли значение левого операнда, чем значение правого. Если да, то условие становится истинным.        | 5 > 2 в результате будет True.<br/>True > False в результате будет True.<br/>"A" > "B" в результате будет False.         |
| **<**    | Проверяет меньше ли значение левого операнда, чем значение правого. Если да, то условие становится истинным.        | 3 < 5 в результате будет True.<br/>True < False в результате будет False.<br/>"A" < "B" в результате будет True.         |
| **>=**   | Проверяет больше или равно значение левого операнда, чем значение правого. Если да, то условие становится истинным. | 1 >= 1 в результате будет True.<br/>23 >= 3.2 в результате будет True.<br/>"C" >= "D" в результате будет False.          |
| **<=**   | Проверяет меньше или равно значение левого операнда, чем значение правого. Если да, то условие становится истинным. | 4 <= 5 в результате будет True.<br/>0 <= 0.0 в результате будет True.<br/>-0.001 <= -36 в результате будет False.        |

Логические операторы

| Оператор | Описание                                                                                               | Примеры                                                                                                                    |
|----------|--------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------|
| **and**  | Логический оператор "И". Условие будет истинным если оба операнда истина.                              | True and True равно True.<br/>True and False равно False.<br/>False and True равно False.<br/>False and False равно False. |
| **or**   | Логический оператор "ИЛИ". Если хотя бы один из операндов истинный, то и все выражение будет истинным. | True or True равно True.<br/>True or False равно True.<br/>False or True равно True.<br/>False or False равно False.       |
| **not**  | Логический оператор "НЕ". Изменяет логическое значение операнда на противоположное.                    | not True равно False.<br/>not False равно True.                                                                            |

Операторы тождественности

| Оператор   | Описание                                                       | Примеры                                              |
|------------|----------------------------------------------------------------|------------------------------------------------------|
| **is**     | Возвращает истину, если оба операнда указывают на один объект. | x is y вернет истину, если id(x) будет равно id(y).  |
| **is not** | Возврашает ложь если оба операнда указывают на один объект.    | x is not y, вернет истину если id(x) не равно id(y). |

## Последовательности (list, set, tuple, dict)

### Списки list

Список в питоне это аналог динамического массива в C++ или ArrayList в java. По сути это последовательность элементов
какого-либо типа.

Способы создания списков:

```python
list1 = list([1, 2, 3])
list2 = [3, 4, '121']
```

Методы работы со списками:

| Метод                              | Что делает                                                                                          |
|------------------------------------|-----------------------------------------------------------------------------------------------------|
| **list.append**(x)                 | Добавляет элемент в конец списка                                                                    |
| **list.extend**(L)                 | Расширяет список list, добавляя в конец все элементы списка L                                       |
| **list.insert**(i, x)              | Вставляет на i-ый элемент значение x                                                                |
| **list.remove**(x)                 | Удаляет первый элемент в списке, имеющий значение x. ValueError, если такого элемента не существует |
| **list.pop**([i])                  | Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент           |
| **list.index**(x, [start [, end]]) | Возвращает положение первого элемента со значением x (при этом поиск ведется от start до end)       |
| **list.count**(x)                  | Возвращает количество элементов со значением x                                                      |
| **list.sort**([key=функция])       | Сортирует список на основе функции                                                                  |
| **list.reverse**()                 | Разворачивает список                                                                                |
| **list.copy**()                    | Поверхностная копия списка                                                                          |
| **list.clear**()                   | Очищает список                                                                                      |

Списки удобно использовать для хранения множеста неуникальных значений

### Множества set

Набор уникальных значений. Способы создания множества:

```python
set1 = set()
set2 = {1, 2, 'a'}
```

Особенностью работы с множествами является то, что они не могут содержать изменяемые элементы, такие как списки и
словари

Методы множеств

| Метод          | Описание                                                                                         | Пример                                                   | Вывод        |
|----------------|--------------------------------------------------------------------------------------------------|----------------------------------------------------------|--------------|
| set.add(e)     | Добавить элемент во множество                                                                    | s = set()<br/>s.add(1)<br />print(s)                     | {1}          |
| set.remove(e)  | Удалить элемент множества. Возвращает исключение KeyError, если элемент не принадлежит множеству | s = {1, 2, 3}<br/><br />s.remove(2)<br/>print(s)         | {1, 3}       |
| set.discard(e) | Удалить элемент, если он принадлежит множеству                                                   | s = {1, 2, 3}<br/>s.discard(2)<br/> print(s)             | {1, 3}       |
| set.pop()      | Вернуть и удалить произвольный элемент множества                                                 | s = {1, 2, 3}<br/>x = s.pop()<br />print(x)<br/>print(s) | {1, 3}<br/>2 |
| set.clear()    | Очистить множество, удалив все его элементы                                                      | s = {1, 2, 3}<br/>s.clear()<br/>print(s)                 | set()        |

### Словари dict

Ассоциатиынй массив, или же хеш-таблица. По сути хранилище элементов различного типа в виде ключ->значение.

Способ создания:

```python
dict1 = {'a': 1, 'b': 1}
dict2 = dict({'a': 1, 'b': 1})

# Получить элемент
dict1['a']
dict1.get('a')
```

Основное преимущество словаря в том, что доступ к элементам осуществляется по ключу (обычно строковому)

Методы работы со словарем

| Операция               | Описание                                                                                         | Пример                                                                                     | Вывод                                |
|------------------------|--------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|--------------------------------------|
| len(d)                 | Возвращает количество ключей в словаре                                                           | d = {"a": 1, "b": 2, "c": 3}<br />print(len(d))                                            | 3                                    |
| del d[key]             | Удалить ключ из словаря. Если ключа нет, то вызывается исключение KeyError                       | d = {"a": 1, "b": 2, "c": 3}<br />del d["b"]<br />print(d)                                 | {"a": 1, "c": 3}                     |
| dict.clear()           | Удалить все ключи и значения в словаре                                                           | d = {"a": 1, "b": 2, "c": 3}<br />d.clear()<br />print(d)                                  | {}                                   |
| dict.copy()            | Возвращает копию словаря                                                                         | d = {"a": 1, "b": 2, "c": 3}<br/>d_new = d.copy()<br/>print(d_new)                         | {"a": 1, "b": 2, "c": 3}             |
| dict.get(key, default) | Возвращает значение по ключу key. Если ключа нет, то возвращает значение default                 | d = {"a":1, "b": 2, "c": 3}<br/>print(d.get("e", "Ключа нет в словаре"))                   | Ключа нет в словаре                  |
| dict.items()           | Возвращает итерируемый объект, состоящий из кортежей (ключ, значение) словаря                    | d = {"a":1, "b": 2, "c": 3}<br/>for key, value in d.items():<br/>    print(key, value)     | a<br />1<br/>b<br /> 2<br/>c<br /> 3 |
| dict.keys()            | Возвращает итерируемый объект, состоящий из ключей словаря                                       | d = {"a": 1, "b": 2, "c": 3}                                                               | <br />b<br/>c                        |
| d.pop(key, default)    | Возвращает значение по ключу key и удаляет его из словаря. Если ключа нет, то возвращает default | d = {"a": 1, "b": 2, "c": 3}<br/>x = d.pop("a")<br/>print(x)                               | 1                                    |
| dict.values()          | Возвращает итерируемый объект, состоящий из значений словаря                                     | d = {"a": 1, "b": 2, "c": 3}<br/>for value in d.values():<br/><br /><br />    print(value) | 1<br/>2<br/>3                        |

Операторы членства

| Оператор   | Описание                                                                                  | Примеры                                                                                                                                                                                                         |
|------------|-------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **in**     | Возвращает истину, если элемент присутствует в последовательности, иначе возвращает ложь. | "cad" in "cadillac" вернет True.<br/>1 in [2,3,1,6] вернет True.<br/>"hi" in {"hi":2,"bye":1} вернет True.<br/> 2 in {"hi":2,"bye":1} вернет False (в словарях проверяется наличие в ключах, а не в значениях). |
| **not in** | Возвращает истину если элемента нет в последовательности.                                 | Результаты противоположны результатам оператора in.                                                                                                                                                             |

## Ветвления

Оператор `if` является началом условной конструкции. Далее идёт условие, которое возвращает логическое значение `True` (
истина) или `False` (ложь). Завершается условие символом «двоеточие». Затем — обязательный отступ в четыре пробела, он
показывает, что строки объединяются в один блок. Отступ аналогичен использованию фигурных скобок или ключевых слов begin
и end в других языках программирования.

Тело условной конструкции может содержать одно или несколько выражений (строк). По завершении тела может идти следующее
условие, которое начинается с оператора `elif` (сокращение от `else if` — «иначе если»). Оно проверяется только в
случае, если предыдущее условие не было истинным.

Синтаксис в `elif` аналогичен `if`. Операторов `elif` для одного блока условного оператора может быть несколько, а может
не быть совсем. Последним идёт оператор `else`, который не содержит условия, а выполняется, только если ни одно из
предыдущих условий в `if` и `elif` не выполнилось. Оператор `else` не является обязательным.

```python
text = input()
if "добр" in text:
    print("Встретилось 'доброе' слово.")
else:
    print("Добрых слов не найдено.")
```

В Python версии 3.10 появился оператор match. В простейшем случае он последовательно сравнивает значение выражения с
заранее заданными в операторах case. А затем выполняет код в операторе case, значение в котором соответствует
проверяемому. Напишем программу, которая сравнивает значение текущего сигнала светофора с одним из трёх вариантов (
красный, жёлтый или зелёный):

```python
color = input()
match color:
    case 'красный' | 'жёлтый':
        print('Стоп.')
    case 'зелёный':
        print('Можно ехать.')
    case _:
        print('Некорректное значение.')
```

Подробнее можно прочитать на [оф. сайте питона](https://docs.python.org/3/tutorial/controlflow.html#match-statements)

## Циклы

Питон поддерживает 2 вида циклов: `while` и `for`. Их отличе состоит в том, что `while` - цикл с условием, т.е. цикл
работает пока выполняется условие, а цикл `for` - это цикл со счетчиком, т.е. он нужен когда мы хотим повторить какое-то
действие n раз или перебрать элементы какой-либо коллекции.
Способ записи циклов аналогичен условным операторам.
Пример:

```python
print("Введите первую и последнюю буквы русского алфавита.")
first_letter = input()
last_letter = input()
if (first_letter == "а" or first_letter == "А") and (
        last_letter == "я" or last_letter == "Я"):
    print("Верно.")
else:
    print("Неверно.")
```

### Цикл for

Он часто применяется вместе с функцией `range`:

```python
for i in range(10):
    print(i)
```

Функция range() может принимать от одного до трёх целочисленных аргументов:

* `range(n)` — возвращает диапазон целых чисел от 0 до n - 1. Например, `range(4)` вернёт диапазон целых чисел: 0, 1, 2,
  3;
* `range(k, n)` — возвращает диапазон целых чисел от k до n - 1. Например, `range(1, 5)` вернёт диапазон целых чисел: 1,
  2, 3, 4;
* `range(k, n, s)` — возвращает диапазон целых чисел от k до n - 1 с шагом s. Например, `range(1, 10, 2)` вернёт
  диапазон целых чисел: 1, 3, 5, 7, 9.

Также с его помощью можно беребирать любые коллекции и строки:

```python
a = [1, 2, 4]

for i in a:
    print(i)

some_str = 'Hello, World!'

for i in some_str:
    print(i)
```

### Цикл while

Используется когда надо выполнять какое-либо действие до тех пор пока выполняется условие. Например:

```python
name = input("Введите имя: ")
while name != "СТОП":
    print(f"Привет, {name}!")
    name = input("Введите имя: ")
print("Программа завершена.")
```

При работе с циклами очень часто применяются операторы `continue` и `break` первый применяется когда надо "перескочить"
на следующую итерацию цикла, а второй когда выйти из него.

Например:

```python

# Вывести все четные числа из диапазона 0 - 10 кроме  4
for i in range(11):
    if i == 4:
        continue  # тут мы перепрыгиваем сразу на следующий шаг, т.е. следующий далее код  в этой итерации выполнен не будет
    if i % 2 == 0:
        print(i)

# вывести первое не отрицательное число
nums = [-1, -3, 4, -1, 2]
for i in nums:
    if i > 0:
        print(i)
        break  # а вот тут мы завершим цикл, как только наткнемся на цифру 4, т.к. она неотрицательная, и дальше мы не будем проходить по циклу 
```

## Функции

Функции это неотъемлемая часть любой программы. ПО сути это программа в программе.
Чтобы объявить функцию в питоне надо использовать ключевое слово `def`.
Например:

```python

def some_function(a: int) -> None:
    print(a * a)


def some_function_return(a: int) -> int:
    return a * a

```

Самым главным преимуществом функций в питоне является то, что функция тоже объект и мы можем передать ее в качестве
аргумента другой функции.
Например:

```python
from typing import Callable


def produce(exec: Callable[[int], int], a: int) -> int:
    return exec(a)


def square(a: int) -> int:
    return a * a


num = produce(square, 2)

print(num)  # 4

```

Функции поддерживают _именованные_ аргументы, т.е. при вызове функции мы можем указать имя аргумента, например:

```python
def send_money(amount, to):
    pass


send_money(100, to='Pasha')
```

Основной плюс этой возможности, заключается в том, что при использовании именованных аргументов, порядок их следования
не важен.

Помимо именованных аргументов, питон поддержиавает _значение по-умолчанию_ т.е. мы можем сами задать значение, которое
примет аргумент функции если не будет передан.
Единственный нюанс работы со значением по-умолчанию заключается в том, что все аргументы без значения по-умолчанию,
должны обьявляться до аргументов со значением по умолчанию.

```python
def send_money(to, amount=100):
    pass


send_money('Pasha')
```

Также в качестве аргументов функции можно иногда увидеть такие конструкции:

- `*args`
- `**kwargs`

Это специальные конструкции, которые позволяют функции принимать произвольное количество аргументов.
Вместо `args` и `kwargs` могут быть произвольные переменные, вся магия содержится в `*` и `**`.

`*<name>` - создает аргумент-список с названием `<name>` в который помещаются все входящие значения, т.е. все аргументы
становятся элементами списка
`**<name>` - создает аргумент-словарь с названием `<name>` в который помещаются все входящие именованные аргументы,
ключем словаря служит 'имя' аргумента.

Это может быть очень полезно при работе с консольными командами, а также используется в большинстве феймворков.

```python
from typing import List


def sum(*nums: List[int]) -> int:
    a = 0
    for num in nums:
        a = a + num
    return a


def send_money(**kwargs):
    to = kwargs.get('to')
    amount = kwargs.get('amount')
    send(to, amount)
```

# Материалы к уроку

1. https://docs.python.org/3/library/typing.html типизация
2. https://docs.python.org/3/library/stdtypes.html встроенные типы данных
3. https://kirill-sklyarenko.ru/lenta/zvezdochki-v-python-chto-eto-i-kak-ispolzovat про `*` и `**`
4. https://python-scripts.com/range немного о `range`
5. https://eternalhost.net/blog/razrabotka/komandy-python большой список встроенных методов
6. https://digitology.tech/docs/python_3/library/stdtypes.html большой перечень инфы по встроенным типам и операциям с
   ними
7. https://all-python.ru/osnovy/generator-spiska.html генерация списков

# Домашнее задание

Необходимо разработать программу для управления банковскими счетами. Программа должна предоставлять возможность создания
новых счетов, пополнения и снятия денег, просмотра информации о текущем балансе, а также выполнения операции перевода
средств между счетами.

Для хранения информации о счетах будет использоваться список словарей, где каждый словарь будет представлять информацию
об одном счете. Каждый словарь в списке будет содержать ключи "Номер счета", "ФИО владельца", "Текущий баланс".

Операции со счетом будут реализованы в виде функций:

1. `create_account(accounts, number, name, amount)` - функция для создания нового счета. Принимает аргументы - номер
   счета, ФИО владельца, начальный баланс.

2. `deposit(accounts, number, amount)` - функция для пополнения счета. Принимает аргументы - номер счета, сумму
   пополнения.

3. `withdraw(accounts, number, amount)` - функция для снятия денег со счета. Принимает аргументы - номер счета, сумму
   снятия.

4. `transfer(accounts, sender, receiver, amount)` - функция для перевода средств между счетами. Принимает аргументы -
   номер счета отправителя, номер счета получателя, сумму перевода.

5. `get_balance(accounts, number)` - функция для получения текущего баланса. Принимает аргумент - номер счета.

Необходимо предусмотреть валидацию входных параметров, например, нельзя переводить отрицательные суммы денег или нельзя
выполнять перевод со счета, если на нем меньше денег чем сумма перевода.
Аннотирование типов необязательно.